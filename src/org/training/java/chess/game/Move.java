package org.training.java.chess.game;

import java.security.InvalidParameterException;

import org.training.java.chess.model.coordinate.BoardCoordinate;
import org.training.java.chess.model.figures.Figure;
import org.training.java.chess.model.figures.FigureFactory;

/**
 * Move with from Coordinate to Coordinate
 * Contains all information necessary to make a move and take it back: Figures, Fields, board, ep, ...
 * @author Peter Heide, pheide@t-online.de
 * @version 1 
 */
public class Move implements Comparable<Move>, Cloneable {	
	
	/** From figure runtime class that moves */
	private Class<? extends Figure> from;
	/** Figure runtime class that gets beaten. Might be pawn exchanger figure. 
	 * Might be null. Is also null when en passant move*/
	private Class<? extends Figure> beaten;
	/** Runtime class when pawn exchanges */
	private Class<? extends Figure> exchange;
	
	/** Coordinate of from Figure before the move */
	private BoardCoordinate fromCoord;
	/** Coordinate of from Figure after the move */
	private BoardCoordinate toCoord;
	/** Coordinate of enPassant field before the move */
	private BoardCoordinate enPassantCoord;
	
	/** Could white castle to the short side before move? */
	private boolean ooWhite = true; 
	/** Could white castle to the long side before move? */
	private boolean oooWhite = true; 
	/** Could black castle to the short side before move? */
	private boolean ooBlack = true; 
	/** Could black castle to the long side before move? */
	private boolean oooBlack = true;	

	/**
	 * Constructor clones all figures
	 * @param from figure that moves
	 * @param beatenFigure or null
	 * @param fromCoord wher figure stands before move
	 * @param toCoord wher figure stands after move
	 * @param exchange figure for pawn exchange into other figure
	 * @param enPassant coordinate before move
	 * @param ooWhite before move
	 * @param oooWhite before move
	 * @param ooBlack before move
	 * @param oooBlack before move
	 * @throws InvalidMoveException 
	 */
	public Move(Class<? extends Figure> from, Class<? extends Figure> beaten, 
		Class<? extends Figure> exchange, 
		BoardCoordinate fromCoord, BoardCoordinate toCoord, BoardCoordinate enPassantCoord, 
		boolean ooWhite, boolean oooWhite, boolean ooBlack, boolean oooBlack) {
		
		int toColumn = toCoord.getColumn();
		if (from == org.training.java.chess.model.figures.Pawn.class && 
		      (toColumn == 0 || toColumn == 7) && exchange != null)

		if (from == null || toCoord == null || 
		      (from == org.training.java.chess.model.figures.Pawn.class && 
			  (toColumn == 0 || toColumn == 7) && exchange == null)
			) 
		{
			throw new InvalidParameterException(getClass().getSimpleName() + 
				": from=" + from + ", beaten=" + beaten + ", exchang=" + exchange +
				", fromCoord=" + fromCoord + ", toCoord=" + toCoord + 
				", enPassantCoord=" + enPassantCoord + ", ooWhite=" + ooWhite + 
				", oooWhite=" + oooWhite + ", ooBlack=" + ooBlack + ", oooBlack=" + oooBlack);		
		}		
		
		this.from = from;
		this.beaten = beaten;
		this.exchange = exchange;
		
		this.fromCoord = fromCoord;
		this.toCoord = toCoord;
		this.enPassantCoord = enPassantCoord;  
		
		this.ooWhite = ooWhite;
		this.oooWhite = oooWhite;
		this.ooBlack = ooBlack;
		this.oooBlack = oooBlack;		
	}

	/**
	 * Getter for white short castling before move
	 * @return the ooWhite
	 */
	public boolean isOoWhite() {
		return ooWhite;
	}

	/**
	 * Getter for white long castling before move
	 * @return the oooWhite
	 */
	public boolean isOooWhite() {
		return oooWhite;
	}

	/**
	 * Getter for black short castling before move
	 * @return the ooBlack
	 */
	public boolean isOoBlack() {
		return ooBlack;
	}

	/**
	 * Getter for black short castling before move
	 * @return the oooBlack
	 */
	public boolean isOooBlack() {
		return oooBlack;
	}
	
	/**
	 * Getter for EnPassantBefore
	 * @return the enPassantBefore
	 */
	public BoardCoordinate getEnPassant() {
		return enPassantCoord;
	}

	/**
	 * Getter for from figure runtime class
	 * @return the from
	 */
	public Class<? extends Figure> getFrom() {
		return from;
	}

	/**
	 * Getter for to figure runtime class
	 * @return the beaten
	 */
	public Class<? extends Figure> getBeaten() {
		return beaten;
	}

	/**
	 * Getter for exchange figure runtime class
	 * @return the exchange
	 */
	public Class<? extends Figure>  getPawnExchange() {
		return exchange;
	}

	/** hashCode for Collections generated by eclipse
	 * @see java.lang.Object#hashCode()
	 */

	/** equals generated by eclipse
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	
	/** Generate move Sting like E2E4 or KG1F3
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuffer buffer = new StringBuffer();
		buffer.append(fromCoord);
		buffer.append(toCoord);
		return buffer.toString();
	}

	/**
	 * Sorts according to figure values
	 * Beating a figure increases value
	 * Pawn exchange increases figure value, too
	 *   in most cases Queen.value - Pawn.value
	 *  Returns a negative integer, zero, or a positive integer as this object is 
	 *  less than, equal to, or greater than the specified object. 
	 */
	@Override
	public int compareTo(Move o) {
		if (o == null) {
			throw new InvalidParameterException("Move must not be null");
		}
		if (this == o) {
			return 0;
		}
		int result = 0;
		// Pawn exchange
		//Integer thisValue = Math.abs(fromFigure.getValue() - toFigure.getValue());
		// Beaten figure
		if (beaten != null) {
			Figure figure = FigureFactory.createFigure(beaten, true);
			result -= figure.getValue();
		}
		Class<? extends Figure> otherBeaten = o.getBeaten();
		if (otherBeaten != null) {
			Figure figure = FigureFactory.createFigure(otherBeaten, true);
			result += figure.getValue();
		}
		// Pawn exchange
		if (exchange != null) {
			Figure figure = FigureFactory.createFigure(
					org.training.java.chess.model.figures.Pawn.class, true);
			result += figure.getValue();
			figure = FigureFactory.createFigure(exchange, true);
			result -= figure.getValue();
		}
		Class<? extends Figure> otherExchange = o.getExchange();
		if (otherExchange != null) {
			Figure figure = FigureFactory.createFigure(
					org.training.java.chess.model.figures.Pawn.class, true);
			result -= figure.getValue();
			figure = FigureFactory.createFigure(otherExchange, true);
			result += figure.getValue();
		}
		
		return result;
	}
	
	/** Clones the Move
	 * Board will not be cloned, reference to board stays the same
	 * @return cloned Object
	 * @see java.lang.Object#clone()
	 */
	@Override
	public Move clone() throws CloneNotSupportedException {
		Move cloneMove = null;
		cloneMove = (Move) super.clone();
		if (fromCoord != null) {
			cloneMove.fromCoord = fromCoord.clone();
		}
		if (toCoord != null) {
			cloneMove.toCoord = toCoord.clone();
		}
		if (enPassantCoord != null) {
			cloneMove.enPassantCoord = enPassantCoord.clone();
		}
		return cloneMove;
	}	

	/**
	 * Getter for en passant pawn move
	 * @return if en passant move
	 */
	public boolean isEnPassant() {
		return from == org.training.java.chess.model.figures.Pawn.class && 
			   fromCoord.getColumn() != toCoord.getColumn() &&
			   beaten == null;
	}
	
	/**
	 * Beat move is when figure gets beaten or en passant
	 * @return true when beat move, false otherwise
	 */
	public boolean isBeatMove() {
		return beaten != null || isEnPassant();
	}

	/**
	 * Material changes when figure gets beaten (including en passant) or pawn exchange
	 * @return true when material changes
	 */
	public boolean isMaterialChange() {
		return isBeatMove() || exchange != null;
	}

	/**
	 * Auto-generated by eclipse
	 * @return hashCode value
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((beaten == null) ? 0 : beaten.hashCode());
		result = prime * result
				+ ((enPassantCoord == null) ? 0 : enPassantCoord.hashCode());
		result = prime * result
				+ ((exchange == null) ? 0 : exchange.hashCode());
		result = prime * result + ((from == null) ? 0 : from.hashCode());
		result = prime * result
				+ ((fromCoord == null) ? 0 : fromCoord.hashCode());
		result = prime * result + (ooBlack ? 1231 : 1237);
		result = prime * result + (ooWhite ? 1231 : 1237);
		result = prime * result + (oooBlack ? 1231 : 1237);
		result = prime * result + (oooWhite ? 1231 : 1237);
		result = prime * result + ((toCoord == null) ? 0 : toCoord.hashCode());
		return result;
	}

	/**
	 * Auto-generated by eclipse
	 * @return equals value
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Move other = (Move) obj;
		if (beaten == null) {
			if (other.beaten != null)
				return false;
		} else if (!beaten.equals(other.beaten))
			return false;
		if (enPassantCoord == null) {
			if (other.enPassantCoord != null)
				return false;
		} else if (!enPassantCoord.equals(other.enPassantCoord))
			return false;
		if (exchange == null) {
			if (other.exchange != null)
				return false;
		} else if (!exchange.equals(other.exchange))
			return false;
		if (from == null) {
			if (other.from != null)
				return false;
		} else if (!from.equals(other.from))
			return false;
		if (fromCoord == null) {
			if (other.fromCoord != null)
				return false;
		} else if (!fromCoord.equals(other.fromCoord))
			return false;
		if (ooBlack != other.ooBlack)
			return false;
		if (ooWhite != other.ooWhite)
			return false;
		if (oooBlack != other.oooBlack)
			return false;
		if (oooWhite != other.oooWhite)
			return false;
		if (toCoord == null) {
			if (other.toCoord != null)
				return false;
		} else if (!toCoord.equals(other.toCoord))
			return false;
		return true;
	}

	public Class<? extends Figure> getExchange() {
		return exchange;
	}

	public BoardCoordinate getFromCoord() {
		return fromCoord;
	}

	public BoardCoordinate getToCoord() {
		return toCoord;
	}

	public BoardCoordinate getEnPassantCoord() {
		return enPassantCoord;
	}
}
